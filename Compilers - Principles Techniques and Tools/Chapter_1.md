# Section 1.1 #

## Excercise 1.1.1 ##

Compiler: Generates a target program, in which the user can call to process inputs and produce outputs.

Interpreter: Directly executes operations on the inputs supplied from the user.

## Exercise 1.1.2

* Compiler over Interpreter: Faster execution of programs

* Interpreter over Compiler: Better error reporting 

## Exercise 1.1.3

Assembly language is easier to produce and debug, in case the compiler has errors in it's manufacturing.

## Exercise 1.1.4

Using C as a target language is helpful, since it is low level enough to manage memory directly, but high level enough to be easy to read and find errors in the compiler. Another advantage is that C has great compilers that can be used to compile it to machine code.

## Exercise 1.1.5

The assembler needs 
* to transate assembly to machine code,
* to resolve jumps and external memory adresses.

# Section 1.3

## Exercise 1.3.1 ##

1. C
    * Imperative
    * Von Neumann
    * Third-generation 
2. C++
    * Imperative
    * Von Neumann
    * Object-oriented
    * Third-generation
3. Cobol
    * Imperative
    * Von Neumann
    * Third-generation

4. Fortran
    * Imperative
    * Von Neumann
    * Third-generation

5. Java
    * Imperative
    * Von Neumann
    * Object-oriented
    * Third-generation
6. Lisp
    * Declerative
    * Von Neumann
    * Functional
    * Third-generation
7. ML
    * Declerative
    * Von Neumann
    * Functional
    * Third-generation
8. Perl
    * Imperative
    * Von Neumann
    * Object-oriented
    * Functional
    * Third-generation
9. Python
    * Imperative
    * Von Neumann
    * Functional
    * Object-oriented
    * Third-generation
    * Scripting
10. VB
    * Imperative
    * Von Neumann
    * Third-generation
